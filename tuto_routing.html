<!DOCTYPE html><html lang="en"><head><title>ZinkyJS:Routing</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content="It makes routes inheritance possible. It makes your code clean and reusable over application. It makes project separated into fullstack modules. It's ExpressJS friendly. It's ZinkyJS"><link rel="shortcut icon" href="images/logo.png"><link href="https://fonts.googleapis.com/css?family=Ubuntu|Ubuntu+Mono" rel="stylesheet"><link rel="stylesheet" href="./css/prism.css"><!-- PURE CSS--><link rel="stylesheet" href="./bower_components/pure/pure-min.css"><link rel="stylesheet" href="./bower_components/pure/grids-responsive-min.css"><!-- Plugins CSS--><link rel="stylesheet" href="./bower_components/font-awesome/css/font-awesome.css"><link rel="stylesheet" href="./bower_components/mdi/css/materialdesignicons.min.css"><!-- Theme CSS--><link id="theme-style" rel="stylesheet" href="./css/style.css"></head><body><div class="lateral-page"><div class="header"><a class="header-logo" href="index.html"><div class="header-logo-img-wrapper"><img class="header-logo-img" src="images/logo.png"></div><div class="header-logo-title">ZinkyJS</div></a><div class="flex"></div><div id="nav"><div class="menu-hor menu"><a class="menu-item" href="tuto_hello.html"><i class="mdi mdi-road-variant"></i> Tutorial</a><a class="menu-item" href="reference.html"><i class="mdi mdi-book-open-page-variant"></i> Docs</a><a class="menu-item" href="https://github.com/zinkyjs/zinky"> <i class="mdi mdi-github-circle"></i> Github</a><a class="menu-item" href="https://github.com/zinkyjs/zinky/issues"><i class="mdi mdi-alert-circle"></i> Support</a></div></div></div><div class="doc-wrapper"><div class="doc-header"><div class="doc-title"><i class="icon mdi mdi-road-variant"></i> Routing</div><div class="meta"><i class="fa fa-clock-o"></i> Last updated: 8 - 4 - 2019 </div></div><div class="scrollable absolute-menu" id="menu-wrapper"><ul class="menu" id="content-menu"><li><a href="tuto_hello.html">Hello World</a></li><li class="active"><a href="tuto_routing.html">Routing</a></li><li><a href="tuto_hooks.html">Hooks</a></li><li><a href="tuto_views.html">Views & Templating Engines</a></li><li><a href="tuto_errors.html">Error Handling</a></li><li><a href="tuto_serve.html">Serving Files</a></li><li><a href="tuto_inheritance.html">Inheritance</a></li><li><a href="tuto_zongel.html">Model with Zongel</a></li></ul></div><div class="doc-content"><section class="doc-section"><h2 class="section-title"></h2><div class="section-block">ZinkyJS's routing style is one of the awesome features that make this framework special. 
Unlike most of other frameworks in which you attach functions to routes, in ZinkyJS, routes know automatically which function to run.
This makes the project architecture more clear, indeed, by reading the url you know where the code handling the request is located in your project.</div><ul class="sections-list"><a href="#convention-section"><li>Convention</li></a><a href="#code-section"><li>Functions Code</li></a><a href="#values-section"><li>Params, Query & Body</li></a><a href="#root-section"><li>Module's Root</li></a><a href="#aliases-section"><li>Aliases</li></a><a href="#notfound-section"><li>If Not Found</li></a></ul></section><section class="doc-section" id="convention-section"><h2 class="section-title">Convention</h2><div class="section-block"> As said earlier, in ZinkyJS apps, functions are attached automatically to routes. And they are organized in a way that lets you locate the code handling the request easily.
This idea requires making some conventions, to become possible.<p>ZinkyJS splits every request path by "/" into parts, each one of them has its meaning:</p><ol class="text-list"><li>First part: <div class="li-desc">Refers to the module</div></li><li>Second part: <div class="li-desc">Refers to the action (function) in the module</div></li><li>Rest of parts: <div class="li-desc">Are read as parameters grouped in an array </div></li></ol><p>Eg:</p><pre><code class="language-javascript"> /users/create/Omar/premium
translates to:
  "users": module name
  "create": action
  "Omar": first parameter
  "premium": second parameter</code></pre></div></section><section class="doc-section" id="code-section"><h2 class="section-title">Functions Code</h2><div class="section-block"> Every function that matches a route resides in the "index.js" of its module.<p>A function name is composed of two parts separated by an underscore ("_"):</p><ol class="text-list"><li>Method: <div class="li-desc">GET, POST, PUT... (uppercase)</div></li><li>Action: <div class="li-desc">The request action (saw above)</div></li></ol><p>Eg:</p><pre><code class="language-javascript"> GET /users/create/Omar/premium
The function that handles this request is 'GET_create' located in 'app_modules/users/index.js'</code></pre><p>In ZinkyJS, these functions are called <span class="ht">operations</span> </p><p>So:</p><pre><code class="language-javascript"> GET /users/create/Omar/premium
translates to:
  "users": module name
  "create": action
  "GET_create": operation
  "Omar": first parameter
  "premium": second parameter</code></pre><p>So, let's write the code:</p><p>1. Create the "users" module by running:</p><pre><code class="code-cli">zinky -M users</code></pre><p>2. Add this method(operation) to the class in "app_modules/users/index.js":</p><pre><code class="language-javascript"> GET_create(req, res) {
  res.end(`create user with name: ${req.params[0]} as: ${req.params[1]}`);
}</code></pre><p>3. Visit <a class="ht" href="localhost:3000/users/create/Omar/premium" target="_blank">localhost:3000/users/create/Omar/premium</a>, and see the result!</p></div></section><section class="doc-section" id="values-section"><h2 class="section-title">Direct Responder</h2><div class="section-block"> Instead of putting the response in <span class="ht">res.end</span> or <span class="ht">req.json</span>, you can just return it in the function as you used to do in any other function.<p>So instead of that:</p><pre><code class="language-javascript"> GET_create(req, res) {
  res.end(`create user with name: ${req.params[0]} as: ${req.params[1]}`);
}</code></pre><p>You can do this:</p><pre><code class="language-javascript"> GET_create(req, res) {
  return `create user with name: ${req.params[0]} as: ${req.params[1]}`;
}</code></pre><p>This is very useful, when you have a function that acts as an operation and as a helper at the same time.</p></div></section><section class="doc-section" id="values-section"><h2 class="section-title">Params, Query & Body</h2><div class="section-block"> In addition to params, we can send request values just as we do traditionally:<p>- Query:</p><pre><code class="language-javascript"> // for: GET /users/create/Omar/premium?gender=male
GET_create(req, res) {
  req.query  // will look like: {gender: "male"}
  req.params // will look like: ['Omar', 'premium']
}</code></pre><p>- Body: you will find the request body in <span class="ht">req.body</span></p></div></section><section class="doc-section" id="root-section"><h2 class="section-title">Module's Root</h2><div class="section-block"> We saw that ZinkyJS parses the url and searches for the action to know what function it should call. 
But sometimes, you simply don't need an action.<p>Imagine we want to get users. It would be sufficient to just request  <span class="ht">GET /users/</span>, without specifying any action. ZinkyJS makes this possible by calling to  <span class="ht">root</span> action if no action found.<br>So you write in "app_modules/users/index.js":</p><pre><code class="language-javascript"> GET_root(req, res) {
  var users = ['Mohamad', 'AbuBakr', 'Omar', 'Othman'];
  res.json(users);
}</code></pre></div></section><section class="doc-section" id="aliases-section"><h2 class="section-title">Aliases</h2><div class="section-block"> ZinkyJS gives the possibility to call a module by a different name than the one you gave to its folder.<p>If for any reason you want to replace "users" in the request by something else, we'll say "customers" for example, you will just have to add <span class="ht">aliases</span> property to app object, like this:</p><pre> <code class="language-javascript">const Zinky = require('zinky');

var app = new Zinky({
 aliases: {
    'customers': 'users'
  }
});

app.listen();</code></pre><p>That way, any time ZinkyJS finds "customers" as module name, it will call "users" module.</p><h3>Usefulness of aliases</h3><p>The aliases prop is very useful as it resolves a problem we face in every ZinkyJS project.<br>We saw in the previous course how to make a home page, but 'www.example.com/home' is not an acceptable home page route.<br>A website home page should be accessible by this route 'www.example.com'.</p><p>Here comes the 'aliases' super hero to resolve that. So you tell ZinkyJS that if no module name is given, call the home module:</p><pre> <code class="language-javascript">const Zinky = require('zinky');

var app = new Zinky({
 aliases: {
    '': 'home'
    'customers': 'users'
  }
});

app.listen();</code></pre></div></section><section class="doc-section" id="notfound-section"><h2 class="section-title">If Not Found</h2><div class="section-block"> If the module or the operation does not exist, ZinkyJS will throw:<pre> <code class="language-cli">{ statusCode: 404 }</code></pre><p>Check the <a class="ht" href="tuto_errors.html" target="_blank">error handling course</a> for further details.</p></div></section><a class="next_page" href="tuto_hooks.html">Next Course: Hooks <div class="fa fa-arrow-right"></div></a></div></div></div><script src="./bower_components/smooth-scroll/dist/js/smooth-scroll.js"></script><script src="./bower_components/scrollbot/js/scrollbot.min.js"></script><script src="./js/prism.js"></script><script src="./js/main.js"></script></body></html>