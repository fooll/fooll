extends ./lateral-layout.pug

block page-title
  | Tutorial

block header-title
  i.icon.fa.fa-road
  |  Tutorial

block menu
  li #[a(data-scroll, href="#installation-section") Installation]
  li #[a(data-scroll, href="#generate-section") Generate Application]
  li #[a(data-scroll, href="#generate-module") Application Module]
  li #[a(data-scroll, href="#routing") Routing]
  li #[a(data-scroll, href="#inheritance") Inheritance]
  li #[a(data-scroll, href="#middlewares") Express Middlewares]
  li #[a(data-scroll, href="#more") Learn More]

block content
  section#download-section.doc-section
    h2.section-title Introduction
    .section-block
      |In this tutorial, we'll get you through a quick tour in which we'll demonstrate the 
      | main features of Zinky framework and to help you understand its main concepts.
  section#installation-section.doc-section
    h2.section-title Installation
    .section-block 
      | We'll be using zinky-cli to generate the app and its modules through the command line.
      p Open CLI and run:
      pre
        code.code-cli npm install -g zinky-cli
  section#generate-section.doc-section
    h2.section-title Generate Application
    .section-block 
      | Now open the CLI in the directory in which you want to store the app.
      p And run:
      pre
        code.code-cli zinky -a myApp
      p A new folder containing your app is now created.
      p Run:
      pre
        code.code-cli cd myApp
      p Then:
      pre
        code.code-cli npm install
    .section-block
      | Here's how the app directory looks like:
      pre
        code.language-markup 
          | myApp
          |   |_ public
          |   |_ app.js
          |   |_ package.json
  section#generate-module.doc-section
    h2.section-title Application Module
    .section-block 
      | The app has not yet any module, so we'll generate one called #[span.ht home] that will handle our application home page.
      p Run:
      pre
        code.code-cli zinky -M home
      p A module called #[span.ht home] has been generated in #[span.ht app_modules], the directory now looks like this:
      pre
        code.language-markup 
          | myApp
          |   |_ app_modules
          |     |_ home
          |       |_ client
          |       |_ views
          |       |_ index.js
          |   |_ public
          |   |_ app.js
          |   |_ package.json
    .section-block 
      | Open #[span.ht app_modules/home/index.js] and add 
      code res.end('This is home Page');
      |  to #[span.ht GET_root] method.
      p So the file will look like:
      pre
        code.language-javascript 
          | const Foola = require('foola');
          | class Home extends Foola {
          |
          |   GET_root(req, res) {
          |     res.end('This is home Page');
          |   }
          |
          | }
          |
          | module.exports = Home;
      p Run the app with:
      pre
        code.code-cli node app.js
      p Now, if you visit #[span.ht localhost:3000/home/], you'll get something like this:
      p
        img(src="./images/screens/home1.png")
      | Create the file #[span.ht app_modules/home/views/index.pug] with this content:
      pre
        code.language-jade
          | html
          |   head
          |     title My App Zinky
          |   body
          |     #header myApp
          |     #content This is super clean
      p And replace the code in #[span.ht app_modules/home/index.js] by this:
      pre
        code.language-javascript 
          | const Foola = require('foola');
          | class Home extends Foola {
          |
          |   GET_root(req, res) {
          |     res.render(this.views.index);
          |   }
          |
          | }
          |
          | module.exports = Home;
      p Now, if you visit #[span.ht localhost:3000/home/], you'll get something like this:
      p
        img(src="./images/screens/home2.png")
      p Let's make some style to this page.
      p Create a file #[span.ht style.css] in #[span.ht /public/] with this content:
      pre
        code.language-css 
          | #header {
          |   background-color: #4588ce;
          |   color: #FFF;
          |   padding: 20px;
          |   font-size: 30px;
          | }
          |
          | #content {
          |   padding: 20px;
          |   color: #282828;
          | }
      p And add this line of code to #[span.ht head] tag in #[span.ht app_modules/home/views/index.pug]:
      pre
        code.language-jade 
          | link(rel="stylesheet", href="/file/style.css")
      p Now, if you visit #[span.ht localhost:3000/home/], you'll get something like this:
      p
        img(src="./images/screens/home3.png")
      p Now, We want to call some javascript that's specific to our #[span.ht home] module.
      p So we create a file #[span.ht app_modules/home/client/main.js] with this content:
      pre
        code.language-javascript
          | document.getElementById('content').innerHTML += 'This text is added by Javascript';
      p And add this line of code to the end of #[span.ht body] tag in #[span.ht app_modules/home/views/index.pug]:
      pre
        code.language-jade 
          | script(src="/home/file/main.js")
      p Now, if you visit #[span.ht localhost:3000/home/], you'll get something like this:
      p
        img(src="./images/screens/home4.png")
    .section-block
      | You probably noticed that a home page in a website should be accessible from the domain's root instead of having its own route.
      P In our case we should access #[span.ht home] from #[span.ht localhost:3000] instead of #[span.ht localhost:3000/home/].
      p Zinky makes it easy to achieve that. Just set #[span.ht aliases] options to server in #[span.ht /app.js]:
      pre 
        code.language-javascript
          | const Zinky = require('zinky');
          |
          | var server = new Zinky({
          |  aliases: {
          |     '': 'home'
          |   }
          | });
          |
          | server.listen();
      p Now, from #[span.ht localhost:3000], you can access what we used to get from #[span.ht localhost:3000/home/]. Try it!
  section#routing.doc-section
    h2.section-title Routing
    .section-block
      | We'll now, learn how to route with #[span.ht ZinkyJS].
      p But before we start, let's make a new module called #[span.ht login]. by running:
      pre
        code.code-cli zinky -M login
      p Now create a file #[span.ht app_modules/login/views/index.pug] with this content:
      pre
        code.language-jade
          | html
          |   head
          |     title My App Zinky: Login
          |   body
          |     #header myApp
          |     #content
          |       form(method="post",action="/login/signin")
          |         input(name="username")
          |         input(name="password",type="password")
          |         button Submit
      p And render the view when the module's root is resquested. So make the file #[span.ht app_modules/login/index.js] look like this: 
      pre
        code.language-javascript
          | const Foola = require('foola');
          | class Login extends Foola {
          |
          |   GET_root(req, res) {
          |     res.render(this.views.index);
          |   }
          |
          | }
          |
          | module.exports = Login;
      p Now, if you visit #[span.ht localhost:3000/login/] you'll find the form that sends a #[span.ht POST] request to #[span.ht /login/signin].
      p #[span.ht /login/signin] means that the request will call the function #[span.ht signin] in the named #[span.ht login] module.
      p But wait! it's a a #[span.ht POST] request, so it will look for #[span.ht POST_signin] in #[span.ht login] module.
      p So let's write this function. Add this code to #[span.ht Login] class:
      pre
        code.language-javascript
          |   POST_signin(req, res) {
          |     console.log(req.body);
          |     res.end('the form data has been received');
          |   }
      p You should know how to try it! So don't hesitate to do.
      p
        .callout-block.callout-info
          .icon-holder
            i.fa.fa-info-circle
          .content
            .callout-title Other methods (PUT,DELETE...)
            p Of course you can use the other methods. For instance, if you have a #[span.ht PUT] request, it will call #[span.ht PUT_actionName].
  section#inheritance.doc-section
    h2.section-title Inheritance
    .section-block
      p Now, we'll discover another great feature in #[span.ht ZinkyJS]. We'll make a module that extends from another one.
      p Imagine we want to make a module that adds a register function to #[span.ht login] module, but without changing it.
      p We'll make a new module called #[span.ht authentication] that extends from #[span.ht login]. Run:
      pre
        code.code-cli zinky -M authentication
      p And write this code in its #[span.ht index.js]:
      pre
        code.language-javascript
          | const Login = require('./../login');
          | class Authentication extends Login {
          |
          |   GET_register(req, res) {
          |     res.render(this.views.register);
          |   }
          |
          |   POST_register(req, res) {
          |     console.log(req.body);
          |     res.end('the register form data has been received');
          |   }
          |
          | }
          |
          | module.exports = Authentication;
      p
        .callout-block.callout-warning
          .icon-holder
            i.fa.fa-exclamation-triangle
          .content
            .callout-title Views Are not inherited
            p You should know that views are not inherited. So you have to create #[span.ht /authentication/views/index.pug] which sends the login form to #[span.ht /authentication/signin].
            p And create #[span.ht /authentication/views/register.pug] that contains the register form with #[span.ht POST] as method and #[span.ht /authentication/register] as action.
  section#middlewares.doc-section
    h2.section-title Express middlewares
    .section-block
      p #[span.ht ZinkyJS] supports ExpressJS middlewares. But #[span.ht ZinkyJS] has its proper way to implement them.
      p While in #[span.ht ExpressJS] you write #[code app.use(middleware)], in #[span.ht ZinkyJS] you write #[code server.addHook(middleware)].
      p We'll take the example of #[span.ht express-session] middleware:
      p In Express you would do this:
      pre
        code.language-javascript
          | const session = require('express-session');
          | app.use(session({
          |   secret: 'keyboard cat',
          |   resave: false,
          |   saveUninitialized: true,
          |   cookie: { secure: true }
          | }))
      p In Zinky you write:
      pre
        code.language-javascript
          | const session = require('express-session');
          | server.addHook(session({
          |   secret: 'keyboard cat',
          |   resave: false,
          |   saveUninitialized: true,
          |   cookie: { secure: true }
          | }))
      p So #[span.ht app.js] will look this:
      pre 
        code.language-javascript
          | const Zinky = require('zinky');
          | const session = require('express-session');
          |
          | var server = new Zinky({
          |  aliases: {
          |     '': 'home'
          |   }
          | });
          |
          | server.addHook(session({
          |   secret: 'keyboard cat',
          |   resave: false,
          |   saveUninitialized: true,
          |   cookie: { secure: true }
          | }))
          |
          | server.listen();
  section#more.doc-section
    h2.section-title Learn More
    .section-block
      p Now that you have learned the basics of #[span.ht ZinkyJS], we recommend you to check the documentations #[a(href="/zinky/docs.html") here], which contains all that you need to know about #[span.ht ZinkyJS].
